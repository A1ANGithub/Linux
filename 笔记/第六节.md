# 1.重定向
## 1.1重定向符号
    >   输出重定向到一个文件或设备 覆盖原来的文件
    >!  输出重定向到一个文件或设备 强制覆盖原来的文件
    >>  输出重定向到一个文件或设备 追加原来的文件
    <   输入重定向到一个程序 

## 1.2标准错误重定向符号
    2>  将一个标准错误输出重定向到一个文件或设备覆盖原来的文件b-shell
    2>> 将一个标准错误输出重定向到一个文件或设备追加到原来的文件
    2>&1    将一个标准错误输出重定向到标准输出 注释:1 可能就是代表标准输出
    >&  将一个标准错误输出重定向到一个文件或设备 覆盖原来的文件c-shell
    |&  将一个标准错误管道输送到另一个命令作为输入

## 1.3命令重导向示例
 - 在 bash 命令执行的过程中，主要有三种输出入的状况，分别是：
    1. 标准输入；代码为 0 ；或称为 stdin ；使用的方式为 <
    2. 标准输出：代码为 1 ；或称为 stdout；使用的方式为 1>
    3. 错误输出：代码为 2 ；或称为 stderr；使用的方式为 2>
     - [test @test test]# ls -al > list.txt
         - 将显示的结果输出到 list.txt 文件中，若该文件以存在则予以取代！
     - [test @test test]# ls -al >> list.txt
         - 将显示的结果累加到 list.txt 文件中，该文件为累加的，旧数据保留！
     - [test @test test]# ls -al  1> list.txt   2> list.err
         - 将显示的数据，正确的输出到 list.txt 错误的数据输出到 list.err
     - [test @test test]# ls -al 1> list.txt 2> &1
         - 将显示的数据，不论正确或错误均输出到 list.txt 当中！错误与正确文件输出到同一个文件中，则必须以上面的方法来写！不能写成其它格式！
     - [test @test test]# ls -al 1> list.txt 2> /dev/null
         - 将显示的数据，正确的输出到 list.txt 错误的数据则予以丢弃！ /dev/null ，可以说成是黑洞装置。为空，即不保存。

## 1.4为何要使用命令输出重导向
 - 当屏幕输出的信息很重要，而且我们需要将他存下来的时候；
 - 背景执行中的程序，不希望他干扰屏幕正常的输出结果时；
 - 一些系统的例行命令（例如写在 /etc/crontab 中的文件）的执行结果，希望他可以存下来时；
 - 一些执行命令，我们已经知道他可能的错误讯息，所以想以『 2> /dev/null 』将他丢掉时；
 - 错误讯息与正确讯息需要分别输出时。

## 1.5总结
1. Linux中为每一个进程准备了三个连接标准0，1，2，其中0代表标准输入，1代表标准输出，2代表标准错误输出它们在默认栈上面且默认连接在终端上但也能人为的接到其他文件。
2. 最低可用文件描述符：Lowest-available-fd，由于文件描述符对应单个进程的文件打开表，所以他肯定从第0项、第1项、第2项按次序排列，如果第1项被释放那么第一项位置空闲，再打开文件时将使用第一项空闲出的空间。因此一旦有最低的可用文件描述符，Linux就会使用最低的。
3. shell的0，1，2默认打开，由于所有进程是shell的子进程，继承了shell的0，1，2，因此默认情况下所有进程的0，1，2端口也是打开的
4. 重定向：
     - 方法一:调用close（）函数，比如close（1）之后1与终端的连接释放，1号文件描述符空闲。然后再打开一个文件open（）那么需要获得一个文件描述符作为返回值，这时由于1空闲，那么将会以1打开该文件。在shell中遇到重定向符“>”时会调用fork（）方法创建子进程，并执行close(1)操作，然后再将1连接到重定向符右边的文件中。
     - 方法二：假如在0，1，2都已经创建连接，并且再次open（）一个文件此时该文件连接到3，此时执行close(1),关闭连接1，然后运用dup()函数，即对文件描述符进行复制，对连接建立副本。此时由于1是最低可用文件描述符，执行dup(3)操作1将连接到3所连接的文件上，然后再执行close(3)操作释放3与该文件的连接。如图所示：



# 2.管道
## 2.1管道的概念：
 - 管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：
1. 其本质是一个伪文件(实为内核缓冲区)
2. 由两个文件描述符引用，一个表示读端，一个表示写端。
3. 规定数据从管道的写端流入管道，从读端流出。
## 2.2管道的原理: 
 - 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。
## 2.3管道的局限性：
1. 数据自己读不能自己写。
2. 数据一旦被读走，便不在管道中存在，不可反复读取。
3. 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。
4. 只能在有公共祖先的进程间使用管道。
 - 常见的通信方式有，单工通信、半双工通信、全双工通信。
## 2.4 pipe函数
 - 创建管道
     - int pipe(int pipefd[2]); 
        成功：0；失败：-1，设置errno
 - 函数调用成功返回r/w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。
 - 管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。实现父子进程间通信呢可以采用如下步骤：
     - 1. 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。
     - 2. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。
     - 3. 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。
 - 利用管道进行进程之间的连接
    fork 一个进程，因为管道在内核的一部分是唯一的，fork 之后的临时口（i.e.3,4）仍然会和原先的进程共用一个内核的接口。这时分别对父子进程操作：
     - 对父进程，close（3），close（1），dup(4)，close(4)  
     - 对子进程，close（4），close（0），dup(3)，close(3)
     - 这样就实现了进程之间的管道相连。（所以3、4 只是中间变量的作用，最终输入输出还是0,1）
    
         ![aaa](picture/pipe.png)
# 3. Socket编程
## 3.1什么是socket
    socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –> 读写write/read –> 关闭close”模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。说白了Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。
 - 注意：其实socket也没有层的概念，它只是一个facade设计模式的应用，让编程变的更简单。是一个软件抽象层。在网络编程中，我们大量用的都是通过socket实现的。
## 3.2套接字描述符
 - 套接字描述符其实就是一个整数，我们最熟悉的句柄是0、1、2三个，0是标准输入，1是标准输出，2是标准错误输出。0、1、2是整数表示的，对应的FILE *结构的表示就是stdin、stdout、stderr。套接字API最初是作为UNIX操作系统的一部分而开发的，所以套接字API与系统的其他I/O设备集成在一起。特别是，当应用程序要为因特网通信而创建一个套接字（socket）时，操作系统就返回一个小整数作为描述符（descriptor）来标识这个套接字。然后，应用程序以该描述符作为传递参数，通过调用函数来完成某种操作（例如通过网络传送数据或接收输入的数据）。
 - 对于每个程序系统都有一张单独的表。精确地讲，系统为每个运行的进程维护一张单独的文件描述符表。当进程打开一个文件时，系统把一个指向此文件内部数据结构的指针写入文件描述符表，并把该表的索引值返回给调用者。应用程序只需记住这个描述符，并在以后操作该文件时使用它。操作系统把该描述符作为索引访问进程描述符表，通过指针找到保存该文件所有的信息的数据结构。
## 3.3基本的SOCKET接口函数
 - 在生活中，A要电话给B，A拨号，B听到电话铃声后提起电话，这时A和B就建立起了连接，A和B就可以讲话了。等交流结束，挂断电话结束此次交谈。打电话很简单解释了这工作原理：“open—write/read—close”模式。
 - 服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。如下图所示：

 - 其中socket()函数的形式为：int  socket(int protofamily, int type, int protocol);//返回sockfd （sockfd是描述符）。socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。
 - Server：
    1. 准备socket
    2. 绑定IP 地址和端口号bind
    3. 设置未决度等待队列激活listen
    4. Accept，获得一个文件标识符accept
    5. Read/write 进行操作read/write
    6. Close close
 - Client: 根据ip、port 对server 进行访问
    1. 准备socket socket
    2. 与server 进行连接connect
    3. Read/write 进行操作read/write
    4. Close close
     - 注：
         - 可以运用现有的client：Telnet
         - DAD：传输的是明文
         - AD:传输格式很规范
 - 老师给的服务器代码实例：
    ```
    main(int ac, char *av[]){
        int tcp_socket;
        struct sockaddr_in addr;
        int fd;
        tcp_socket  =  socket(AF_INET,  SOCK_STREAM, 0);
        addr.sin_family=AF_INET;
        addr.sin_port=htons(atoi(av[1]));
        addr.sin_addr.s_addr=INADDR_ANY;

        if(bind(tcp_socket, (const struct sockaddr *)&addr, sizeof(addr))==-1){
            perror("cannot bind");
            exit(1);
        }

        listen(tcp_socket, 1);

        while(1){
            fd=accept(tcp_socket, NULL, NULL);

            write(fd,"This is 10086!\n", 15);

            close(fd);	
        }
    }
    ```